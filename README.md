# Kakaopay 사전과제 - 뿌리기

## 반영스펙
* 데이터보관기간 존재안함(7일간 조회와 별개로 저장기간)
* 단톡방 최대 인원수 1500명(현실 스펙 반영)

### 토큰 발행
* 조건: 3자리 문자열에 예측불가능(non-sequential)
* ASCII코드 printable 문자 개수의 중복가능한 경우의수 804357 (33(!) ~ 126(~), 문자 93개 * 3자리) 랜덤발행
    * 32(space), 127(delete) 제외
* 토큰의 고유성 유효시간: 7일
    * 생성 후 7일동안 uniqueness 지속
    * 토큰으로 받기 API 요청시, 7일 내 유효한 토큰이 있는 뿌리기 데이터 사용
    * 토큰으로 조회 API 요청시, 7일 내에만 조회 할 수 있으므로 접근 할 엔티티가 명확함
        * 조회방법

* 토큰의 고유성을 시간에 둔 이유:
    * 과제에 뿌리기 데이터 보관기간 미설정(영원히 지속된다 가정, 데이터보관기간 설정시 아래작업 실행)
        * 데이터 보관기간이 7일이라면, 배치로 데이터 제거
        * 데이터 보관기간이 7일이라면, 받기 API 요청의 7일 내인지 조건 제거(인덱싱 제거)
        * 데이터 보관기간이 7일이라면, 통계를 위한 데이터는 데이터 생성시 메시지 큐로 메시지 발행         
    * 대화방 지속기간이 길어질 수록 이전에 저장 해둔 토큰과 겹칠 가능성이 늘어남
        
### 금액 분산
* 조건: 뿌릴 인원, 뿌릴 금액
* 분배로직 
    * 금액단위: 1원
    * 뿌릴 최소금액: 1원 * 뿌릴 인원 (적으면 Exception)
    * 균등금액 
        * 뿌리는 금액의 최솟값과 최댓값 차이 0 또는 1원
    * 뿌릴금액 / 뿌릴 인원 의 반내림에서사 나머지의 개수만큼의 아이템에 1원씩 추가
    * 랜덤 정렬후 저장(이후 순차발행) 

### History 저장은 Embedded Document
* 1500명으로 산정하였을때 충분함

### 동시성 처리
* 고려 한 방법
1. findAndModify
    * 각 operation은 원자성이 있으므로 동시성은 걱정안해됨
    * findAndModify를 사용하기에 좋은 마땅한 구조가 안떠오름 
2. PessimisticLocking
    * Isolation level read-repeatable로 설정
    * 재시도로직을 추가할거면 OptimisticLocking 보다 퍼포먼스가 떨어질거로 생각됨 
3. OptimisticLocking
    * 버저닝을 통한 OptimisticLocking 사용
    * 일정 시간 내 재시도 로직 추가
4. 다른 방법
    * counting 할 수 있는 remote-cache를 둔다
    * 메시지큐를 이용 Ambassador 패턴으로 큐를 다시 컨슈밍하여 사용

### SelfTesting 
* @SelfTesting annotation
* Testable interface 

### 테스트코드 
* 여러 일이 겹쳐서 시간이 많이부족했음.. 

 

